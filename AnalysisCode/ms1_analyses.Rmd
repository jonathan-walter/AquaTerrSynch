---
title: 'Q1: Are lake and terrestrial primary productivity coherent?'
author: "Jonathan Walter, Grace Wilkinson, Rachel Fleck, Michael Pace"
date: "4/17/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(aqts)
library(wsyn)
library(rgdal)
library(LAGOSNE)
library(raster)
library(MuMIn)
library(dplyr)
library(nlme)
library(lmerTest)
library(viridis)
library(fields)

rm(list=ls())

```

This document organizes for openness and reproducibility analyses of the temporal coherence of interannual variation in lake primary productivity with terrestrial primary productivity in the landscape surrounding the lake.

# Data import

Data produced in 'ms1_prep.Rmd' are loaded.

```{r load workspace, echo=TRUE, cache=FALSE}

load("/Users/jonathanwalter/Box Sync/NSF EAGER Synchrony/Data/RData files/ms1_analysis_inprogress1.RData")

```

```{r examine missing values, echo=TRUE, cache=FALSE}
any(sapply(analysislakes$lakedata, function(x){any(is.infinite(x))}))
any(sapply(analysislakes$lakedata, function(x){any(is.na(x))}))
which(sapply(analysislakes$lakedata, function(x){any(is.na(x))}))
analysislakes$lakeinfo[which(sapply(analysislakes$lakedata, function(x){any(is.na(x))})),]

# image(accndvi)
# points(lakepts.prj[which(sapply(analysislakes$lakedata, function(x){any(is.na(x))})),])

dbuff[which(sapply(analysislakes$lakedata, function(x){any(is.na(x))}))]

analysislakes$lakeinfo<-analysislakes$lakeinfo[!sapply(analysislakes$lakedata, function(x){any(is.na(x))}),]
analysislakes$lakedata<-analysislakes$lakedata[!sapply(analysislakes$lakedata, function(x){any(is.na(x))})]
```

```{r compute coherences, echo=TRUE, cache=TRUE}

source("~/GitHub/AquaTerrSynch/AnalysisCode/bandtest_coh.R")

tsranges<-rbind(c(2,4),c(4,Inf),c(2,Inf))

coh.chlaXaccndvi<-NULL
coh.chlaXmaxndvi<-NULL

for(lind in 1:length(analysislakes$lakedata)){
  lakedat.ii<-cleandat(analysislakes$lakedata[[lind]], as.numeric(colnames(analysislakes$lakedata[[lind]])), clev=5)$cdat
  chlaXaccndvi<-coh(lakedat.ii[1,], lakedat.ii[2,], as.numeric(colnames(analysislakes$lakedata[[lind]])),
                    norm="powall", sigmethod="fast", nrand=10000)
  chlaXmaxndvi<-coh(lakedat.ii[1,], lakedat.ii[3,], as.numeric(colnames(analysislakes$lakedata[[lind]])),
                    norm="powall", sigmethod="fast", nrand=10000)
  for(rind in 1:nrow(tsranges)){
    chlaXaccndvi<-bandtest.coh(chlaXaccndvi, tsranges[rind,])
    chlaXmaxndvi<-bandtest.coh(chlaXmaxndvi, tsranges[rind,])
  }
  coh.chlaXaccndvi<-rbind(coh.chlaXaccndvi, c(t(as.matrix(chlaXaccndvi$bandp[,3:5]))))
  coh.chlaXmaxndvi<-rbind(coh.chlaXmaxndvi, c(t(as.matrix(chlaXmaxndvi$bandp[,3:5]))))
  
}

coh.chlaXaccndvi<-as.data.frame(coh.chlaXaccndvi)
coh.chlaXmaxndvi<-as.data.frame(coh.chlaXmaxndvi)

colnames(coh.chlaXaccndvi)<-paste0("accndvi",c("p.ts1","phi.ts1","coh.ts1","p.ts2","phi.ts2","coh.ts2","p.ts3","phi.ts3","coh.ts3"))
colnames(coh.chlaXmaxndvi)<-paste0("maxndvi",c("p.ts1","phi.ts1","coh.ts1","p.ts2","phi.ts2","coh.ts2","p.ts3","phi.ts3","coh.ts3"))

coh.chlaXaccndvi$lagoslakeid<-analysislakes$lakeinfo$lagoslakeid
coh.chlaXmaxndvi$lagoslakeid<-analysislakes$lakeinfo$lagoslakeid

```

```{r summarize coherences, echo=TRUE, cache=FALSE}
#short timescales
hist(coh.chlaXaccndvi$accndvicoh.ts1, main="Accumulated NDVI, short timescales", xlab="Coherence", ylab="Frequency")
hist(coh.chlaXmaxndvi$maxndvicoh.ts1, main="Maximum NDVI, short timescales", xlab="Coherence", ylab="Frequency")

quantile(coh.chlaXaccndvi$accndvicoh.ts1)
quantile(coh.chlaXmaxndvi$maxndvicoh.ts1)

alpha=0.05
sum(coh.chlaXaccndvi$accndvip.ts1<alpha)/nrow(coh.chlaXaccndvi)
sum(coh.chlaXmaxndvi$maxndvip.ts1<alpha)/nrow(coh.chlaXmaxndvi)

print(coh.chlaXaccndvi$accndviphi.ts1[coh.chlaXaccndvi$accndvip.ts1<alpha]/pi) #only pattern is that lakes don't lead the landscape
print(coh.chlaXmaxndvi$maxndviphi.ts1[coh.chlaXmaxndvi$maxndvip.ts1<alpha]/pi)

phicls<-c(-1,-.75,-0.25,0.25,0.75,1)

hist(coh.chlaXaccndvi$accndviphi.ts1[coh.chlaXaccndvi$accndvip.ts1<0.2]/pi, main="Accumulated NDVI, short timescales", xlab="Phase (pi)", ylab="Frequency", breaks=phicls)
#hist(coh.chlaXmaxndvi$maxndviphi.ts1[coh.chlaXmaxndvi$maxndvip.ts1<0.2]/pi, main="Maximum NDVI, short timescales", xlab="Phase (pi)", ylab="Frequency", breaks=5)

#long timescales
hist(coh.chlaXaccndvi$accndvicoh.ts2, main="Accumulated NDVI, long timescales", xlab="Coherence", ylab="Frequency")
hist(coh.chlaXmaxndvi$maxndvicoh.ts2, main="Maximum NDVI, long timescales", xlab="Coherence", ylab="Frequency")

quantile(coh.chlaXaccndvi$accndvicoh.ts2)
quantile(coh.chlaXmaxndvi$maxndvicoh.ts2)

alpha=0.05
sum(coh.chlaXaccndvi$accndvip.ts2<alpha)/nrow(coh.chlaXaccndvi)
sum(coh.chlaXmaxndvi$maxndvip.ts2<alpha)/nrow(coh.chlaXmaxndvi)

print(coh.chlaXaccndvi$accndviphi.ts2[coh.chlaXaccndvi$accndvip.ts2<alpha]/pi)
print(coh.chlaXmaxndvi$maxndviphi.ts2[coh.chlaXmaxndvi$maxndvip.ts2<alpha]/pi)

hist(coh.chlaXaccndvi$accndviphi.ts1[coh.chlaXaccndvi$accndvip.ts2<0.2]/pi, main="Accumulated NDVI, long timescales", xlab="Phase (pi)", ylab="Frequency", breaks=phicls)
#hist(coh.chlaXmaxndvi$maxndviphi.ts1[coh.chlaXmaxndvi$maxndvicoh.ts2>0.6]/pi, main="Maximum NDVI, short timescales", xlab="Phase (pi)", ylab="Frequency", breaks=5)

```

```{r mapping, echo=TRUE, cache=FALSE}

states<-readOGR("~/Box Sync/NSF EAGER Synchrony/Data/statesp020.shp")
getstates<-c("Minnesota", "Iowa", "Wisconsin", "Illinois", "Missouri", "Michigan", "Indiana", "Ohio", "Pennsylvania", "New York", "New Jersey", "Connecticut", "New Hampshire", "Rhode Island", "Massachusetts", "Vermont", "Maine")
lagosstates<-states[states@data$STATE %in% getstates,]

plot(lagosstates, main="Lakes selected for analysis")
points(analysislakes$lakeinfo$nhd_long, analysislakes$lakeinfo$nhd_lat, pch=16, cex=1, col="blue")


cohplotdata<-left_join(analysislakes$lakeinfo, coh.chlaXaccndvi, by="lagoslakeid")

pal<-viridis(100)

par(mar=c(1,0,2,0))

plot(lagosstates, main="Lakes by short timescale coherence")
points(cohplotdata$nhd_long, cohplotdata$nhd_lat, pch=16, cex=1, col=pal[round(cohplotdata$accndvicoh.ts1,2)*100])
colorbar.plot(x=mean(par("usr")[1:2]),y=par("usr")[3],strip=1:100,col=pal,horizontal = T)

plot(lagosstates, main="Lakes by long timescale coherence")
points(cohplotdata$nhd_long, cohplotdata$nhd_lat, pch=16, cex=1, col=pal[round(cohplotdata$accndvicoh.ts2,2)*100])
colorbar.plot(x=mean(par("usr")[1:2]),y=par("usr")[3],strip=1:100,col=pal,horizontal = T)

```


```{r add vars for modelling, echo=TRUE, cache=FALSE}

#Need to add: depth, average growing season Chlorophyll-a, TSI(chla) categories, pct ag

#agriculture -- is 500m buffer best? Other options include 100m buffer (probably too small) and hu12 watershed
pct.ag<-lagosne_select(table="buffer500m.lulc", vars=c("lagoslakeid","buffer500m_nlcd2001_pct_82","buffer500m_nlcd2006_pct_82","buffer500m_nlcd2011_pct_82"))
# pct.ag<-lagosne_select(table="hu12.lulc", vars=c("lagoslakeid","hu12_nlcd2001_pct_82","hu12_nlcd2006_pct_82","hu12_nlcd2011_pct_82"))
pct.ag<-pct.ag[pct.ag$lagoslakeid %in% analysislakes$lakeinfo$lagoslakeid,]
pct.ag.avg<-data.frame(lagoslakeid=pct.ag$lagoslakeid, pct.ag=rowMeans(pct.ag[,2:4]))

#depth
depth<-lagosne_select(table="lakes_limno", vars=c("lagoslakeid","maxdepth"))
depth<-depth[depth$lagoslakeid %in% analysislakes$lakeinfo$lagoslakeid,] #use max depth because it's more complete

#growing season Chlorophyll-a
chla<-lagosne_select(table="epi_nutr", vars=c("lagoslakeid","samplemonth","chla"))
chla<-chla[chla$lagoslakeid %in% analysislakes$lakeinfo$lagoslakeid,]
gs.chla<-chla[chla$samplemonth %in% 5:9,]
avg.chla<-aggregate(chla ~ lagoslakeid, data=gs.chla, FUN=mean, na.rm=T)

#Chlorophyll-a TSI class
#TSI(CHL) = 9.81 ln(CHL) + 30.6
tsi.chl<-data.frame(lagoslakeid=avg.chla$lagoslakeid, tsi=9.81 * log(avg.chla$chla) + 30.6)
tsi.chl$tsi.cat<-rep("lake",nrow(tsi.chl))

tsi.chl$tsi.cat[tsi.chl$tsi < 40]<-"oligotrophic"
tsi.chl$tsi.cat[tsi.chl$tsi >=40 & tsi.chl$tsi < 50]<-"mesotrophic"
tsi.chl$tsi.cat[tsi.chl$tsi >=50 & tsi.chl$tsi < 70]<-"eutrophic"
tsi.chl$tsi.cat[tsi.chl$tsi >= 70] <-"hypereutrophic"

#huc2 and huc4 watershed codes
huc_codes<-read.csv("/Users/jonathanwalter/GitHub/AquaTerrSynch/AnalysisCode/match_huc_codes.csv", colClasses = 'character')

predictors<-analysislakes$lakeinfo
predictors$tslength<-predictors$end-predictors$start+1
predictors<-left_join(predictors, depth, by="lagoslakeid")
predictors<-left_join(predictors, pct.ag.avg, by="lagoslakeid")
predictors<-left_join(predictors, avg.chla, by="lagoslakeid")
predictors<-left_join(predictors, tsi.chl, by="lagoslakeid")
predictors<-left_join(predictors, huc_codes, by="hu4_zoneid")

modvars.accndvi<-left_join(predictors, coh.chlaXaccndvi, by="lagoslakeid")
modvars.accndvi$nhd_ftype<-factor(modvars.accndvi$nhd_ftype)
modvars.accndvi$tsi.cat<-factor(modvars.accndvi$tsi.cat)
modvars.accndvi$tslength<-modvars.accndvi$end-modvars.accndvi$start + 1

modvars.accndvi<-modvars.accndvi[!is.na(modvars.accndvi$maxdepth),]
modvars.accndvi<-modvars.accndvi[!is.na(modvars.accndvi$pct.ag),]

modvars.accndvi.phist<-modvars.accndvi[modvars.accndvi$accndvip.ts1<0.2,]
modvars.accndvi.philt<-modvars.accndvi[modvars.accndvi$accndvip.ts2<0.2,]
```

```{r gls modelling, echo=TRUE, cache=FALSE}
#short timescales
gls.coh.accndvi.st<-gls(accndvicoh.ts1 ~ maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi,
                       correlation=corExp(form = ~ nhd_lat + nhd_long))
summary(gls.coh.accndvi.st)
suppressWarnings(dredge.coh.accndvi.st<-dredge(gls.coh.accndvi.st, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.coh.accndvi.st))

gls.p.accndvi.st<-gls(accndvip.ts1 ~ tslength + maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi,
                       correlation=corExp(form = ~ nhd_lat + nhd_long))
summary(gls.p.accndvi.st)
suppressWarnings(dredge.p.accndvi.st<-dredge(gls.p.accndvi.st, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.p.accndvi.st))

gls.phi.accndvi.st<-gls(cos(accndviphi.ts1) ~ maxdepth + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi.phist) #remove ftype b/c only lakes
summary(gls.phi.accndvi.st)
suppressWarnings(dredge.phi.accndvi.st<-dredge(gls.phi.accndvi.st, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.phi.accndvi.st))

#long timescales
gls.coh.accndvi.lt<-gls(accndvicoh.ts2 ~ maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi,
                       correlation=corExp(form = ~ nhd_lat + nhd_long))
summary(gls.coh.accndvi.lt)
suppressWarnings(dredge.coh.accndvi.lt<-dredge(gls.coh.accndvi.lt, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.coh.accndvi.lt))

gls.p.accndvi.lt<-gls(accndvip.ts2 ~ tslength + maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi,
                       correlation=corExp(form = ~ nhd_lat + nhd_long))
summary(gls.p.accndvi.lt)
suppressWarnings(dredge.p.accndvi.lt<-dredge(gls.p.accndvi.lt, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.p.accndvi.lt))

gls.phi.accndvi.lt<-gls(cos(accndviphi.ts2) ~ maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + huc2_code, data=modvars.accndvi.philt,
                       correlation=corExp(form = ~ nhd_lat + nhd_long))
summary(gls.phi.accndvi.lt)
suppressWarnings(dredge.phi.accndvi.lt<-dredge(gls.phi.accndvi.lt, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.phi.accndvi.lt))
```

GLS models sucked, but inspection of results suggested that mixed effects models with random effects of region on the intercept may likely be an improvement.

```{r mixed modelling, echo=TRUE, cache=FALSE}
lme.coh.accndvi.st<-lmer(accndvicoh.ts1 ~ maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi, na.action="na.fail")
summary(lme.coh.accndvi.st)
suppressWarnings(dredge.coh.accndvi.st<-dredge(lme.coh.accndvi.st, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.coh.accndvi.st))

lme.p.accndvi.st<-lmer(accndvip.ts1 ~ tslength + maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi, na.action="na.fail")
summary(lme.p.accndvi.st)
suppressWarnings(dredge.p.accndvi.st<-dredge(lme.p.accndvi.st, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.p.accndvi.st))

lme.phi.accndvi.st<-lmer(accndviphi.ts1 ~ maxdepth + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi.phist, na.action="na.fail")
summary(lme.phi.accndvi.st)
suppressWarnings(dredge.phi.accndvi.st<-dredge(lme.phi.accndvi.st, beta="sd")) #model with TSI is unconvincingly better than intercept-only (dAIC = 0.92)
print(head(dredge.phi.accndvi.st))

lme.coh.accndvi.lt<-lmer(accndvicoh.ts2 ~ maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi, na.action="na.fail")
summary(lme.coh.accndvi.lt)
suppressWarnings(dredge.coh.accndvi.lt<-dredge(lme.coh.accndvi.lt, beta="sd")) #lake type is marginal improvement over intercept only (dAIC = 0.1)
print(head(dredge.coh.accndvi.lt))

lme.p.accndvi.lt<-lmer(accndvip.ts2 ~ tslength + maxdepth + nhd_ftype + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi, na.action="na.fail")
summary(lme.p.accndvi.lt)
suppressWarnings(dredge.p.accndvi.lt<-dredge(lme.p.accndvi.lt, beta="sd")) #intercept only is best model. Disappointing.
print(head(dredge.p.accndvi.lt))

lme.phi.accndvi.lt<-lmer(accndviphi.ts2 ~ maxdepth + lake_area_ha + pct.ag + chla + tsi.cat + (1|huc2_code), data=modvars.accndvi.philt, na.action="na.fail")
summary(lme.phi.accndvi.lt)
suppressWarnings(dredge.phi.accndvi.lt<-dredge(lme.phi.accndvi.lt, beta="sd")) #model with TSI is unconvincingly better than intercept-only (dAIC = 0.92)
print(head(dredge.phi.accndvi.lt))

```

Adding random effects of huc2 region on intercept helped somewhat. Some possibilities are to add more detailed lake type classes, and to model 2-3 regions separately.