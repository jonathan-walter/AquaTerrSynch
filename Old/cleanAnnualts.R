#' Clean annual time series of lake and terrestrial NDVI data
#' 
#' \code{cleanAnnualts} performs routine cleaning and filtering on annualized time series. 
#' 
#' @param indat an input data list, e.g. output from 'makeLAGOSannualts'
#' @param ymin minumum time series length
#' @param maxNA maximum number of missing observations per time series. If 0< maxNA<1, maxNA is the maximum proportion of NAs allowed.
#' @param optim the variable whose time series length to optimize. Defaults to \code("chla"}. 
#' @param fill.method the method for filling missing observations. Currently, only 'median' is implemented.
#' @param timespan a vector giving the min and max of a range of years which data will be restricted to.
#' 
#' @return \code{cleanAnnualts} returns an object of class \code{list}. Slots are:
#' \item{lakeinfo}{A data frame of lake information generated by, e.g., \code{makeLAGOSannualts}.}
#' \item{lakedata}{A list of data frames containing the lake data, as generated by, e.g., \code{makeLAGOSannaults}.}
#' 
#' @details \code{cleanAnnualts} takes as input a list generated by \code{makeLAGOSannualts}, possibly augmented by \code{makeAVHRRannualts},
#' \code{makeIowaALMannualts}, or other dataset building functions. It cleans the data, finding optimal stretches of data meeting length
#' and completeness requirements set by \code{ymin} and \code{maxNA}. Currently, \code{optim} sets a single variable to optimize time series
#' based on, but possibly future updates will include opimitization on multiple variables. Missing values are filled only if they are non-consecutive. 
#' If no variables meet requirements, the whole lake is dropped from the output. If some, but not all variables meet requirements, 
#' data are returned with the offending variables ommitted. Data should still be inspected and explored prior to 
#' analysis, and in some cases some manual bespoke cleaning may be necessary for certain lakes and variables.
#' 
#' @author Jonathan Walter, \email{jaw3es@@virginia.edu}
#' 
#' @seealso \code{\link{makeLAGOSannualts}}
#' 
#' @examples
#' #need to add some
#' 
#' @export

cleanAnnualts<-function(indat, ymin=20, maxNA=2, timespan=NULL, fill.method="median"){
  
  library(zoo)
  
  cleandat<-indat$lakedat
  cleaninfo<-indat$lakeinfo
  
  droplakes<-NULL
  
  if(maxNA < 0){stop("Negative values of maxNA not allowed")}
  
  for(lind in 1:length(indat$lakedata)){
    
    dat.lind<-indat$lakedata[[lind]]
    
    if(all(is.na(dat.lind))){
      droplakes<-c(droplakes,lind)
      next
    }
    
    if(!is.null(timespan)){ #if necessary, limit data to selected timespan
      dat.lind<-dat.lind[,colnames(dat.lind)>=min(timespan) &
                           colnames(dat.lind)<=max(timespan)]
    }
    
    #Drop leading or trailing NAs
    dat.lind<-t(na.trim(t(dat.lind),sides="both",is.na="all"))
    
    if(maxNA < 1){maxNA<-ceiling(ncol(dat.lind)*maxNA)}
    
    #check for ymin
    
    if(diff(range(as.numeric(colnames(dat.lind)))) < (ymin-1)){
      droplakes<-c(droplakes,lind)
    }
    
    else{
      #check for max NA
      dropvars<-NULL
      for(vind in 1:nrow(dat.lind)){
        if(sum(is.na(dat.lind[vind,]))>maxNA){
          dropvars<-c(dropvars,vind)
          next
        }
        #check if there are consecutive NAs
        rle.vind<-rle(is.na(dat.lind[vind,]))
        if(any(rle.vind$lengths[rle.vind$values]>1)){
          dropvars<-c(dropvars,vind)
          next
        }
      }
      if(!is.null(dropvars)){dat.lind<-dat.lind[-dropvars,]}
      
      if(nrow(dat.lind)==0){
        droplakes<-c(droplakes, lind)
        next
      }
      
      #fill time series if sporadic NAs
      for(vind in 1:nrow(dat.lind)){
        if(fill.method!="median"){stop("only fill.method=median is implemented")}
        else{
          dat.lind[vind,is.na(dat.lind[vind,])]<-median(dat.lind[vind,], na.rm=T)
        }
      }
    }
    cleandat[[lind]]<-dat.lind
    if(length(dat.lind)==0){droplakes<-c(droplakes, lind)}
  }
  
  if(!is.null(droplakes)){
    cleandat<-cleandat[-droplakes]
    cleaninfo<-cleaninfo[-droplakes,]
    }
  #adjust start and end columns of lakeinfo
  
  for(ii in 1:nrow(cleaninfo)){
    cleaninfo$start[ii]<-min(as.numeric(colnames(cleandat[[ii]])))
    cleaninfo$end[ii]<-max(as.numeric(colnames(cleandat[[ii]])))
  }
  
  return(list(lakeinfo=cleaninfo,lakedata=cleandat,cleaned=TRUE))
  
}


