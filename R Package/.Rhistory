# plot(1:t3,(colSums(comm3)-mean(colSums(comm3)))/mean(colSums(comm3)),type="l",lwd=2)
#library(mvtnorm)
set.seed(11)
#species-poor community, no synchrony
n1=3
t1=100
p1=20
# rho1=0
# sigma1=matrix(rho1,n1,n1)
# diag(sigma1)<-1
#comm1<-t(rmvnorm(t1,sigma=sigma1))
comm1<-matrix(0,n1,t1)
for(nn in 1:n1){
dd=runif(1,-1,1)+nn
comm1[nn,]<-sin(seq(0+(2*pi/n1)*dd,2*pi*(t1/p1)+(2*pi/n1)*dd,length.out = t1))
}
n2=30
t2=t1
p2=p1
comm2<-matrix(0,n2,t2)
for(nn in 1:n2){
dd=runif(1,-1,1)+nn
comm2[nn,]<-sin(seq(0+(2*pi/n2)*dd,2*pi*(t2/p2)+(2*pi/n2)*dd,length.out = t2))
}
# rho2=0
# sigma2=matrix(rho2,n2,n2)
# diag(sigma2)<-1
#
# comm2<-t(rmvnorm(t2,sigma=sigma2))
n3=n2
t3=t1
p3=p1
# rho3=0.5
# sigma3<-matrix(rho3,n3,n3)
# diag(sigma3)<-1
#
# comm3<-t(rmvnorm(t3,sigma=sigma3))
comm3<-matrix(0,n2,t2)
for(nn in 1:n2){
comm3[nn,]<-sin(seq(0+(pi/n3)*(nn-1),2*pi*(t3/p3)+(pi/n3)*(nn-1),length.out = t3))
}
pdf("~/Box Sync/CommVar_EcoFunction/comm_var_nototal.pdf",width=5,height=3)
par(mfrow=c(1,3),mar=c(2.6,2.6,2.1,1),oma=c(1.5,1.5,0,0))
plot(NA,NA,ylim=c(-5,5),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n1){
lines(1:t1,comm1[nn,],col=rainbow(n1)[nn])
}
#lines(1:t1,colSums(comm1),lwd=2)
mtext("n=3 spp, no synch.",3)
plot(NA,NA,ylim=c(-5,5),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n2){
lines(1:t2,comm2[nn,],col=rainbow(n2)[nn])
}
#lines(1:t2,colSums(comm2),lwd=2)
mtext("n=15 spp, no synch.",3)
plot(NA,NA,ylim=c(-5,5),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n2){
lines(1:t3,comm3[nn,],col=rainbow(n2)[nn])
}
#lines(1:t3,colSums(comm3),lwd=2)
mtext("n=15 spp, synch.",3)
mtext("Time",1,outer=T)
mtext("Biomass",2,outer=T)
dev.off()
pdf("~/Box Sync/CommVar_EcoFunction/comm_var_example.pdf",width=5,height=3)
par(mfrow=c(1,3),mar=c(2.6,2.6,2.1,1),oma=c(1.5,1.5,0,0))
plot(NA,NA,ylim=c(-20,20),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n1){
lines(1:t1,comm1[nn,],col=rainbow(n1)[nn])
}
lines(1:t1,colSums(comm1),lwd=2)
mtext("n=3 spp, no synch.",3)
plot(NA,NA,ylim=c(-20,20),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n2){
lines(1:t2,comm2[nn,],col=rainbow(n2)[nn])
}
lines(1:t2,colSums(comm2),lwd=2)
mtext("n=15 spp, no synch.",3)
plot(NA,NA,ylim=c(-20,20),xlim=c(1,100),xlab="",ylab="")
for(nn in 1:n2){
lines(1:t3,comm3[nn,],col=rainbow(n2)[nn])
}
lines(1:t3,colSums(comm3),lwd=2)
mtext("n=15 spp, synch.",3)
mtext("Time",1,outer=T)
mtext("Biomass",2,outer=T)
dev.off()
# plot(1:t1,(colSums(comm1)-mean(colSums(comm1)))/mean(colSums(comm1)),type="l",lwd=2)
# plot(1:t2,(colSums(comm2)-mean(colSums(comm2)))/mean(colSums(comm2)),type="l",lwd=2)
# plot(1:t3,(colSums(comm3)-mean(colSums(comm3)))/mean(colSums(comm3)),type="l",lwd=2)
tt=seq(1,tmax,by=dt)
dt=1/24/4 #days, 15-minute data
tmax=365 #days
mu=0
sigma=1
t.h=30*8 #when does the hurricane hit, days
d.h=3 #change due to hurricane
rec.time=10 #how long it takes to recover
tt=seq(1,tmax,by=dt)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
plot(sig1)
seq(0,1,length.out=rec.time*dt)
source('~/.active-rstudio-document')
seq(0,1,by=rec.time*dt)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
plot(sig1)
plot(tt)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
plot(tt,yy)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
help(spline)
spline.yy<-spline(tt,yy)
spline.yy<-spline(tt,yy)
plot(tt,yy,type="l")
lines(spline.yy, col="red")
plot(tt,yy,type="l")
help("smooth.spline")
spline.yy<-smooth.spline(tt,yy)
plot(tt,yy,type="l")
lines(spline.yy, col="red")
par(mfrow=c(2,1))
plot(tt,yy,type="l")
lines(spline.yy, col="red")
plot(deriv.spline)
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
help(ecdf)
## ------------------------------------------------------------
## Work on distributions
baseline<-yy[tt<t.h]
recovery<-yy[tt>t.h & tt<t.h+rec.time]
basedist<-ecdf(baseline)
plot(basedist)
## Work on distributions
baseline<-yy[tt<t.h]
recovery<-yy[tt>t.h & tt<t.h+rec.time]
basedist<-ecdf(baseline)
recovery<-ecdf(recovery)
plot(basedist)
plot(basedist)
plot(recovery)
summary(bsedist)
summary(basedist)
op <- par(mfrow = c(3, 1), mgp = c(1.5, 0.8, 0), mar =  .1+c(3,3,2,1))
F10 <- ecdf(rnorm(10))
summary(F10)
plot(F10)
plot(F10, verticals = TRUE, do.points = FALSE)
plot(Fn12 , lwd = 2) ; mtext("lwd = 2", adj = 1)
xx <- unique(sort(c(seq(-3, 2, length = 201), knots(Fn12))))
lines(xx, Fn12(xx), col = "blue")
abline(v = knots(Fn12), lty = 2, col = "gray70")
y <- round(rnorm(12), 1); y[3] <- y[1]
Fn12 <- ecdf(y)
Fn12
knots(Fn12) # unique values (always less than 12!)
summary(Fn12)
summary.stepfun(Fn12)
plot(Fn12 , lwd = 2) ; mtext("lwd = 2", adj = 1)
xx <- unique(sort(c(seq(-3, 2, length = 201), knots(Fn12))))
lines(xx, Fn12(xx), col = "blue")
abline(v = knots(Fn12), lty = 2, col = "gray70")
plot(xx, Fn12(xx), type = "o", cex = .1)  #- plot.default {ugly}
plot(Fn12, col.hor = "red", add =  TRUE)  #- plot method
abline(v = knots(Fn12), lty = 2, col = "gray70")
## luxury plot
plot(Fn12, verticals = TRUE, col.points = "blue",
col.hor = "red", col.vert = "bisque")
range(baseline)
range(recovery)
recovery
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
plot(recovdist)
range(recovery)
minx<-min(c(min(baseline),min(recovery)))
maxx<-max(c(max(baseline),max(recovery)))
xx<-seq(minx,maxx.by=0.025)
xx<-seq(minx,maxx,by=0.025)
basedist(xx)
xx<-seq(minx,maxx,by=0.01)
basedist(xx)
recovdst(xx)
recovdist(xx)
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
tdiff<-basedist(xx)-recovdist(xd)
tdiff<-basedist(xx)-recovdist(xx)
lines(xx,tdiff,col="grey")
tdiff<-(basedist(xx)-recovdist(xx))^2
lines(xx,tdiff,col="grey")
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
30*8
tseries<-yy
refpd=c(0,150)
wwidth=24*4*5 #5-day window on 15-minute data
dx=0.01
dt=1
refseries<-tseries[refpd[1]:refpd[2]]
refdist<-ecdf(refseries)
xx<-seq(min(tseries)-dx, max(tseries)+dx, dx)
wstart<-seq(max(refpd)+1,length(tseries)-wwidth,dt)
wmidpt<-wstart+ww/2
wmidpt<-wstart+wwidth/2
wstart
xx
wstart<-seq(max(refpd)+1,max(tseries)-wwidth,dt)
wwidth
wind<-seq(which(tseries==min(refpd)),length(tseries),by=dt)
which(tseries==min(refpd))
refpd
wind<-seq(from=which(tseries==max(refpd)),length(tseries),by=dt)
which(tseries==max(refpd))
refpd=c(0,150*12*4)
lwwidth=24*4*5 #5-day window on 15-minute data
## Try out some methods for doing recovery time analyses
## ------------------------------------------------------------
## Make a time series to play with
dt=1/24/4 #days, 15-minute data
tmax=365 #days
mu=0
sigma=1
t.h=30*8 #when does the hurricane hit, days
d.h=10 #change due to hurricane
rec.time=10 #days it takes to recover
tt=seq(1,tmax,by=dt)
sig1<-c(
rep(mu,sum(tt<t.h)),
(mu-d.h)+d.h*(seq(0,1,length.out=rec.time/dt)),
rep(mu,sum(tt>=t.h+rec.time))
)
yy=sig1+rnorm(length(tt),0,sigma)
plot(tt,yy,type="l")
## ------------------------------------------------------------
## Try out spline fitting
spline.yy<-smooth.spline(tt,yy)
deriv.spline<-predict(spline.yy,deriv=1)
par(mfrow=c(2,1),mar=c(4.1,4.1,1.1,1.1))
plot(tt,yy,type="l")
lines(spline.yy, col="red")
plot(deriv.spline,type="l",xlab="tt",ylab="1st derivative")
#This uses some kind of optimization to pick smoothing parameters
#but it's clear that the derivative fluctuates naturally unless the spline
#is extremely smooth so still need to define a range of natural variability
#to decide what is a big excursion in the derivative
## ------------------------------------------------------------
## Work on distributions
baseline<-yy[tt<t.h]
recovery<-yy[tt>t.h & tt<t.h+rec.time]
basedist<-ecdf(baseline)
recovdist<-ecdf(recovery)
plot(basedist)
plot(recovdist)
minx<-min(c(min(baseline),min(recovery)))
maxx<-max(c(max(baseline),max(recovery)))
xx<-seq(minx,maxx,by=0.01)
basedist(xx)
recovdist(xx)
plot(xx,basedist(xx),type="l")
lines(xx,recovdist(xx),col="red")
tdiff<-(basedist(xx)-recovdist(xx))^2
lines(xx,tdiff,col="grey")
## make up a function to do roll this out
#assign values to these during development
yy = yy
tt = tt
refpd=c(0,150*12*4)
wwidth=24*4*5 #5-day window on 15-minute data
dx=0.01
dt=1
refseries<-yy[refpd[1]:refpd[2]]
refdist<-ecdf(refseries)
xx<-seq(min(tseries)-dx, max(tseries)+dx, dx)
wind<-seq(from=which(tseries==max(refpd)),length(tseries),by=dt)
wind<-seq(from=which(tt==max(refpd)),length(tseries),by=dt)
wind<-seq(from=which(tt==max(refpd)),length(tt),by=dt)
tt
refpd
wind<-seq(from=max(refpd)+1,length(tt),by=dt)
wind
wstart<-tt[wind]
wstart
wmidpt<-wstart+wwidth/2
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
refpd
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
refpd[1]:refpd[2]
yy[refpd[1]:refpd[2]]
refseries<-yy[refpd[1]:refpd[2]]
refdist<-ecdf(refseries)
xx<-seq(min(tseries)-dx, max(tseries)+dx, dx)
wind<-seq(from=max(refpd)+1,length(tt),by=dt)
wstart<-tt[wind]
ddiff<-rep(NA, length(wind))
for(ww in 1:length(wind)){
wdist<-ecdf(yy[wind[ww]:(wind[ww]+wwidth)])
ddiff[ww]<-(refdist(xx)-wdist(xx))^2
}
warnings()
ww
refdist(xx)
wdist(xx)
distdiff<-function(yy,tt,refpd,wwidth,dx=0.01,dt=1){
#yy = a time series
#tt = the time steps
#refpd = a length-2 vector of starting and ending indices for the reference period
#wwidth = the window width, in number of time steps
#dx = increment between values at which to evaluate differences between reference and recovery distributions
#dt = number of timesteps by which moving window advances
#TODO: given a threshold difference, identify when dist'n changes and returns to refence
#Notes: once we detect changes, can we automatically determine the reference dist'n?
#add error handling and unit tests
refseries<-yy[refpd[1]:refpd[2]]
refdist<-ecdf(refseries)
xx<-seq(min(tseries)-dx, max(tseries)+dx, dx)
wind<-seq(from=max(refpd)+1,length(tt),by=dt)
wstart<-tt[wind]
ddiff<-rep(NA, length(wind))
for(ww in 1:length(wind)){
wdist<-ecdf(yy[wind[ww]:(wind[ww]+wwidth)])
ddiff[ww]<-sum((refdist(xx)-wdist(xx))^2)
}
return(data.frame(wstart=wstart,ddiff=ddiff))
}
test<-distdiff(yy,tt,refpd,wwidth)
plot(test$wstart,test$ddiff)
plot(test$wstart,test$ddiff,type="l")
abline(v=t.h, col="red")
abline(v=t.h+rec.time,col="blue")
distdiff<-function(yy,tt,refpd,wwidth,dx=0.01,dt=1){
#yy = a time series
#tt = the time steps
#refpd = a length-2 vector of starting and ending indices for the reference period
#wwidth = the window width, in number of time steps
#dx = increment between values at which to evaluate differences between reference and recovery distributions
#dt = number of timesteps by which moving window advances
#TODO: given a threshold difference, identify when dist'n changes and returns to refence
#Notes: once we detect changes, can we automatically determine the reference dist'n?
#add error handling and unit tests
refseries<-yy[refpd[1]:refpd[2]]
refdist<-ecdf(refseries)
xx<-seq(min(tseries)-dx, max(tseries)+dx, dx)
wind<-seq(from=max(refpd)+1,length(tt)-length(refpd),by=dt)
wstart<-tt[wind]
ddiff<-rep(NA, length(wind))
for(ww in 1:length(wind)){
wdist<-ecdf(yy[wind[ww]:(wind[ww]+wwidth)])
ddiff[ww]<-sum((refdist(xx)-wdist(xx))^2)
}
return(data.frame(wstart=wstart,ddiff=ddiff))
}
test<-distdiff(yy,tt,refpd,wwidth)
plot(test$wstart,test$ddiff,type="l")
abline(v=t.h, col="red")
abline(v=t.h+rec.time,col="blue")
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/.active-rstudio-document')
plot(yy,type="l")
wt(yy,tt)
yy=yy-mean(yy)
wt(yy,tt)
source('~/.active-rstudio-document')
wt1<-wt(t.series,times)
scale.min=2
scale.max.input=NULL
sigma=1.05
f0=1
#error checking
wsyn:::errcheck_tsdat(times,t.series,"wt")
wsyn:::errcheck_wavparam(scale.min,scale.max.input,sigma,f0,times,"wt")
if(is.null(scale.max.input)){
scale.max<-length(t.series)
}
else{
scale.max<-scale.max.input
}
if (is.matrix(t.series))
{
t.series<-as.vector(t.series)
}
#for return
wtopt<-list(scale.min=scale.min,scale.max.input=scale.max.input,
sigma=sigma,f0=f0)
#determine how many frequencies are in the range and make receptacle for results
scale.min <- f0*scale.min
scale.max <- f0*scale.max
m.max <- floor(log(scale.max/scale.min)/log(sigma))+1 #number of timescales
s2 <- scale.min*sigma^seq(from=0, by=1, to=m.max) #widths of wavelet envelopes
margin2 <- ceiling(sqrt(-(2*s2*s2)*log(0.5)))
m.max
m.max <- floor(log(scale.max/scale.min)/log(sigma))+1 #number of timescales
m.max
#determine how many frequencies are in the range and make receptacle for results
scale.min <- f0*scale.min
scale.max <- f0*scale.max
scale.min
scale.max
if(is.null(scale.max.input)){
scale.max<-length(t.series)
}
scale.max
#determine how many frequencies are in the range and make receptacle for results
scale.min <- f0*scale.min
scale.max <- f0*scale.max
m.max <- floor(log(scale.max/scale.min)/log(sigma))+1 #number of timescales
s2 <- scale.min*sigma^seq(from=0, by=1, to=m.max) #widths of wavelet envelopes
margin2 <- ceiling(sqrt(-(2*s2*s2)*log(0.5)))
translength <- length(t.series)
m.last <- max(which(margin2<0.5*translength))
result <- matrix(NA, nrow=translength, ncol=m.max+1)
wavsize <- ceiling(sqrt(-(2*s2[m.last]*s2[m.last])*log(0.001)));
wavsize
#preparations for finding components
Y <- stats::fft(c(t.series,rep(0,2*wavsize)))
lenY<-length(Y)
freqs<-seq(from=0, by=1, to=lenY-1)/lenY;
freqs2<-c(seq(from=0, by=1, to=floor(lenY/2)), seq(from=-(ceiling(lenY/2)-1),
by=1, to=-1))/lenY;
s2
margin
margin2
stage=1
s.scale<-s2[stage];
s.scale
#margin determines how close large wavelets can come to the edges of the timeseries
margin<-margin2[stage];
margin
XX <- (2*pi*s.scale)^(0.5)*(exp(-s.scale^2*(2*pi*(freqs-((f0/s.scale))))^2/2) -
(exp(-s.scale^2*(2*pi*(freqs2))^2/2))*
(exp(-0.5*(2*pi*f0)^2)))*exp(-1i*2*pi*wavsize*freqs);
con <- stats::fft((XX*Y),inverse=TRUE)
con <- con/length(con)
con
result
dim(result)
margin
translength
dim(XX)
length(XX)
for (stage in 1 : m.last)
{
s.scale<-s2[stage];
#begin calculating wavelet
#margin determines how close large wavelets can come to the edges of the timeseries
margin<-0#margin<-margin2[stage];
#perform convolution
XX <- (2*pi*s.scale)^(0.5)*(exp(-s.scale^2*(2*pi*(freqs-((f0/s.scale))))^2/2) -
(exp(-s.scale^2*(2*pi*(freqs2))^2/2))*
(exp(-0.5*(2*pi*f0)^2)))*exp(-1i*2*pi*wavsize*freqs);
con <- stats::fft((XX*Y),inverse=TRUE)
con <- con/length(con)
#fit result into transform
result[(margin+1):(translength-margin),stage] <-
con[(wavsize + margin + 1):(translength + wavsize - margin)];
}
result
image(Mod(result))
if(is.null(scale.max.input)){
result<-result[,1:m.last]
timescales<-s2[1:m.last]/f0
errcheck_tts(times,timescales,result,"wt")
result<-list(values=result, times=times, wtopt=wtopt, timescales=timescales, dat=t.series)
class(result)<-c("wt","tts","list")
return(result)
}
if(is.null(scale.max.input)){
result<-result[,1:m.last]
timescales<-s2[1:m.last]/f0
wsyn::errcheck_tts(times,timescales,result,"wt")
result<-list(values=result, times=times, wtopt=wtopt, timescales=timescales, dat=t.series)
class(result)<-c("wt","tts","list")
return(result)
}
if(is.null(scale.max.input)){
result<-result[,1:m.last]
timescales<-s2[1:m.last]/f0
wsyn:::errcheck_tts(times,timescales,result,"wt")
result<-list(values=result, times=times, wtopt=wtopt, timescales=timescales, dat=t.series)
class(result)<-c("wt","tts","list")
return(result)
}
result$values
image(Mod(result$values))
source('~/GitHub/wavelet-ewi/wt_noscallop.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
install.packages("Emcdf")
source('~/Box Sync/MethodsDevelopment/recovery_time_20190920.R')
knitr::opts_chunk$set(echo = TRUE)
library(aqts)
source('~/GitHub/AquaTerrSynch/R Package/aqts/build.R')
#rm(list=ls())
library(roxygen2)
library(devtools)
setwd("~/GitHub/AquaTerrSynch/R package")
build("aqts")   # need a folder named 'Reumannplatz', in which a file named DESCRIPTION and a sub-folder named 'R'. This will creat a zip file
document("aqts") # this will create a file 'NAMESPACE' and a folder 'man'
check("aqts")
install("aqts")
build("aqts")   # need a folder named 'Reumannplatz', in which a file named DESCRIPTION and a sub-folder named 'R'. This will creat a zip file
document("aqts") # this will create a file 'NAMESPACE' and a folder 'man'
