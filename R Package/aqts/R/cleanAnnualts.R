#' Clean annual time series of lake and terrestrial NDVI data
#' 
#' \code{cleanAnnualts} performs routine cleaning and filtering on annualized time series. 
#' 
#' @param indat an input data list, e.g. output from 'makeLAGOSannualts'
#' @param ymin minumum time series length
#' @param maxNA maximum number of missing observations per time series. If 0< maxNA<1, maxNA is the maximum proportion of NAs allowed.
#' @param optim the variable whose time series length to optimize. Defaults to \code("chla"}. 
#' @param fill.method the method for filling missing observations. Currently, only 'median' is implemented.
#' @param timespan a vector giving the min and max of a range of years which data will be restricted to.
#' 
#' @return \code{cleanAnnualts} returns an object of class \code{list}. Slots are:
#' \item{lakeinfo}{A data frame of lake information generated by, e.g., \code{makeLAGOSannualts}.}
#' \item{lakedata}{A list of data frames containing the lake data, as generated by, e.g., \code{makeLAGOSannaults}.}
#' 
#' @details \code{cleanAnnualts} takes as input a list generated by \code{makeLAGOSannualts}, possibly augmented by \code{makeAVHRRannualts},
#' \code{makeIowaALMannualts}, or other dataset building functions. It cleans the data, finding optimal stretches of data meeting length
#' and completeness requirements set by \code{ymin} and \code{maxNA}. Currently, \code{optim} sets a single variable to optimize time series
#' based on, but possibly future updates will include opimitization on multiple variables. Missing values are filled only if they are non-consecutive. 
#' If no variables meet requirements, the whole lake is dropped from the output. If some, but not all variables meet requirements, 
#' data are returned with the offending variables ommitted. Data should still be inspected and explored prior to 
#' analysis, and in some cases some manual bespoke cleaning may be necessary for certain lakes and variables.
#' 
#' @author Jonathan Walter, \email{jaw3es@@virginia.edu}
#' 
#' @seealso \code{\link{makeLAGOSannualts}}
#' 
#' @examples
#' #need to add some
#' 
#' @export

cleanAnnualts<-function(indat, ymin=20, maxNA=2, optim="chla", timespan=NULL, fill.method="median"){
  
  cleandat<-indat$lakedata
  cleaninfo<-indat$lakeinfo
  
  droplakes<-NULL
  
  if(maxNA < 0){stop("Negative values of maxNA not allowed")}
  
  for(lind in 1:length(indat$lakedata)){
    
    dat.lind<-indat$lakedata[[lind]]
    if(maxNA < 1){maxNA<-ceiling(ncol(dat.lind)*maxNA)}
    
    if(all(is.na(dat.lind))){
      droplakes<-c(droplakes,lind)
      next
    }
    
    if(!is.null(timespan)){ #if necessary, limit data to selected timespan
      dat.lind<-dat.lind[,colnames(dat.lind)>=min(timespan) &
                           colnames(dat.lind)<=max(timespan)]
    }
    
    #Find optimal time series for the focal variable
    optvar<-dat.lind[rownames(dat.lind)==optim,]
    rle.opt<-rle(!is.na(optvar))
    maxsteps<-length(rle.opt$lengths)
    opt.out<-optvar
    
    nacheck<-function(rle.opt){
      if(!any(!rle.opt$values)){return(TRUE)}
      else if(max(rle.opt$lengths[!rle.opt$values])==1){return(TRUE)}
      else{return(FALSE)}    
    }
    
    for(step in 1:maxsteps){
      if(sum(rle.opt$lengths[rle.opt$values])<(ymin-maxNA)){
        droplakes<-c(droplakes, lind)
        break
        }
      #find out if there are consecutive NAs, and if so take the longer segment
      if(any(rle.opt$lengths[rle.opt$values==FALSE]>1)){
        cut<-min(which(rle.opt$lengths>1 & !rle.opt$values))
        end<-length(rle.opt$lengths)
        if(sum(rle.opt$lengths[1:(cut-1)]) > sum(rle.opt$lengths[min(c(cut+1,length(rle.opt$lengths))):length(rle.opt$lengths)])){
          #take the early segment
          opt.out<-opt.out[1:sum(rle.opt$lengths[1:(cut-1)])]
          rle.opt$lengths<-rle.opt$lengths[1:(cut-1)]
          rle.opt$values<-rle.opt$values[1:(cut-1)]
        }
        else if(sum(rle.opt$lengths[1:(cut-1)]) <= sum(rle.opt$lengths[(cut+1):length(rle.opt$lengths)])){
          #take the late segment
          opt.out<-opt.out[(sum(rle.opt$lengths[1:cut])+1):sum(rle.opt$lengths)]
          rle.opt$lengths<-rle.opt$lengths[(cut+1):end]
          rle.opt$values<-rle.opt$values[(cut+1):end]
        }
      }
      if(sum(rle.opt$lengths[rle.opt$values])>(ymin-maxNA) & 
         sum(rle.opt$lengths[!rle.opt$values])<=maxNA &
         nacheck(rle.opt)){break}
    }
    
    if(length(opt.out) < ymin){
      droplakes<-c(droplakes, lind)
      next
    }
    
    if(lind %in% droplakes){next}
    getyears<-names(opt.out)
    dat.lind<-matrix(dat.lind[,colnames(dat.lind) %in% getyears], nrow=nrow(dat.lind), byrow=T,
                     dimnames=list(rownames(dat.lind),getyears))

    #check for max NA in non-focal variables
    dropvars<-NULL
    for(vind in 1:nrow(dat.lind)){
      if(sum(is.na(dat.lind[vind,]))>maxNA){
        dropvars<-c(dropvars,vind)
        next
      }
      #check if there are consecutive NAs
      rle.vind<-rle(is.na(dat.lind[vind,]))
      if(any(rle.vind$lengths[rle.vind$values]>1)){
        dropvars<-c(dropvars,vind)
        next
      }
    }
    if(!is.null(dropvars)){dat.lind<-dat.lind[-dropvars,]}
    
    if(nrow(dat.lind)==0){
      droplakes<-c(droplakes, lind)
      next
    }
      
    #fill time series if sporadic NAs
    for(vind in 1:nrow(dat.lind)){
      if(fill.method!="median"){stop("only fill.method=median is implemented")}
      else{
        dat.lind[vind,is.na(dat.lind[vind,])]<-median(dat.lind[vind,], na.rm=T)
      }
    }
    cleandat[[lind]]<-dat.lind
    if(length(dat.lind)==0){droplakes<-c(droplakes, lind)}
  }
  
  #drop lakes that failed
  if(!is.null(droplakes)){
    cleandat<-cleandat[-droplakes]
    cleaninfo<-cleaninfo[-droplakes,]
  }
  #adjust start and end columns of lakeinfo
  for(ii in 1:nrow(cleaninfo)){
    cleaninfo$start[ii]<-min(as.numeric(colnames(cleandat[[ii]])))
    cleaninfo$end[ii]<-max(as.numeric(colnames(cleandat[[ii]])))
  }
  
  return(list(lakeinfo=cleaninfo,lakedata=cleandat,cleaned=TRUE))
  
}


